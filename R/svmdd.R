#' Structural VAR estimation
#'
#' The posterior integrated over A+ (the right-hand side coefficients), conditional
#' on A0 and lmd.
#'
#' @details The model is \deqn{A(L)y(t) = \varepsilon(t),} with \eqn{\varepsilon(t)}
#' having a diagonal covariance matrix that varies over time.  The variances change
#' at the dates in  `Tsigbreak', and their relative sizes are in the `lmd' matrix.
#' 
#'#' The marginal density results are only available if the prior is proper, which
#' usually requires all or most of the prior parameters to be non-zero.  But
#' estimation with an improper prior that uses only some of the Minnesota prior
#' dummy observations is also possible.  For example `lambda=3`, `mu=1`, `tight=0`,
#' `w=0`,  (but `sig` non-zero) is a loose improper prior that insulates
#' against estimates that imply unlikely initial transients.   When the prior is
#' improper, `nonorm=TRUE` avoids some unnecessary calculations.
#'
#' For more extensive discussion of the prior parameters see [MNpriorNotes.pdf].
#'
#' Though most commonly `ydata` is just a `mts` object, it can also be a list
#' of such objects.  The main use of this is to allow use of time series with
#' missing observations. The real data must be in blocks with increasing dates.
#'
#' Data as a list also allows direct entry of dummy observations to function as
#' part of the prior, in addition to or in place of the dummy observations
#' generated by the parametric Minnesota prior. Such directly entered dummy
#' observations must come at the end of the list, and must be given the attribute
#' `dummy`, set to `TRUE`. In this case ususally you will want `const=FALSE`.
#' 
#' A "training sample" prior can be implemented with a list element with attribute
#' `train` set to TRUE.  This is real data, with meaningful time series prperties,
#' and must be the first part of the data set.  No shock variance breaks
#' (dates in `Tsigbrk`) can be in the training sample.
#'
#' Changing or eliminating the `dummy` or
#' `train` attributes does not change the posterior distribution,
#' but it does affect the value of `mdd` and thus Bayes factors for model
#' comparison.
#'
#' `OwnLagMeans` may be a single numeric value, the prior mean of the
#' first own lag coefficient in all equations.  If it is a numeric vector of
#' length m, it is the prior mean of the first m lag coefficients in all equations.
#' If it is a `nv` by `m` matrix, each row is the prior mean of the coefficients
#' on the first `m` lags in the corresponding equation.
#'
#' The default is close to the optimal second-order univariate AR coefficients
#' when the variable is a unit-averaged continuous time Wiener process.  This
#' works well for variables like GDP or investment, which cumulate through time.
#' For data that are sampled rather than averaged, like some financial or price
#' data, `OwnLagMeans=1` is better.  
#'
#' @param ydata  Endogenous variable data matrix, including initial condition
#'              dates.  Usually just an mts object.  More generally, it may
#'              be a list of mts objects that will be stacked up for estimation.
#' @param lags   Number of lags in the model.
#' @param xdata Exogenous variable data matrix, including initial condition
#'              dates. A list when ydata is a list.  
#' @param const  Constant term is added automatically if const=TRUE.
#' @param A0     Contemporaneous coefficient matrix --- constant.
#' @param Tsigbrk Dates at which lmd vectors change.  Last date with old lmd (not first
#'                with new).  Can be two-column matrix with rows like c(1947,2),
#'                or vector with absolute dates like 1947.25. 
#' @param lmd    Relative  variances of structural shocks.  Rows for variables,
#'               columns for periods.  Row-averages normalized to one.
#' @param tight Overall tightness of Minnesota prior. `1/tight` is own lag std dev
#' @param decay Standard deviations of lags shrink as `lag^(-decay)`.
#'                  walk behavior
#' @param lambda Weight on the co-persistence prior dummy observation.  If
#'               negative, does not include x's in the dummy observation.
#' @param mu Weight on variable-by-variable sum of coeffs dummy observations.
#'           if negative, does not include x's in the dummy observations
#' @param OwnLagMeans Prior expectation of own lag coefficients in reduced form.
#'                    See details.
#' @param flat Omit conventional uninformative prior on \code{Sigma}?
#' @param nonorm Do not normalize posterior to make it a proper prior
#' @param ic If non-null, do not use initial conditions from \code{ydata} in
#'           forming the prior.  Use \code{ic} instead.
#' @param verbose If FALSE, return only the log marginal posterior density for `A0,lmd'.

#' @return
#' * `w`: Marginal posterior density for `A0`, `lmd`, with `A+` integrated out.
#' * `var`: Output of `svar()` for full sample, including dummy observations.
#' * `varp`: output of `svar()` on prior dummy observations only.
#' + `uts`: residuals for real data, as time series with dates if there are no
#'          breaks, as a list of time series if there are breaks.
#' * also: the input arguments
#' 
#' @md
#' @export
svmdd <- function(ydata,
                  lags,
                  xdata=NULL,
                  const=TRUE,
                  A0,
                  Tsigbrk,
                  lmd,         
                  lambda=5,
                  mu=1,
                  tight=3,
                  decay=.5,
                  sig=rep(.01, NCOL(ydata)),
                  w=1,
                  xsig=NULL,
                  OwnLagMeans = c(1.25, -.25),
                  flat=FALSE,
                  nonorm=FALSE,
                  ic=NULL,
                  verbose=TRUE) {
    if (is.list(ydata)) {
        ylist <- ydata
        nblock <- length(ylist)        
        if (is.null(dim(ylist[[1]]))) {
            lapply(ylist, function(x) matrix(x, ncol=1))
        }
        if (!is.null(xdata)) {
            xlist <- xdata
            stopifnot("xdata must also be a list" = is.list(xdata))
        }
        isdum <- sapply(ylist, function(x) isTRUE(attr(x, "dummy")))
        if (any(isdum)) {
            nblockReal <- match(TRUE, isdum) - 1
        } else {
            nblockReal <- nblock
        }
        Treal <- sum(sapply(ylist[1:nblockReal], function(yl) dim(yl)[1]))
        nv <- ncol(ylist[[1]])
        ydata <- matrix(0, 0, nv)
        if (!is.null(xdata)) {
            if (is.null(dim(xlist[[1]]))) {
                lapply(xlist, function(x) matrix(x, ncol=1))
            }
            nx <- ncol(xlist[[1]])
            xdata <- matrix(0, 0, nx)
        } else {
            nx <- 0
        }
        for (il in 1:nblock) {
            ydata <- rbind(ydata, ylist[[il]])
            if (!is.null(xdata)) {
                xdata <- rbind(xdata, xlist[[i]])
            }
        }
        breaks <- cumsum(sapply(ylist, function(x) dim(x)[1]))
        ## Here breaks includes end  
    } else {
        nblockReal <- 1
        isdum <- FALSE                  #No "manual" dummy blocks
        if (is.null(dim(ydata))) {
            dim(ydata) <- c(length(ydata), 1)
        }
        ylist <- list(ydata)
        xlist <- list(xdata)
        nblock <- 1
        nv <- ncol(ydata)        
        breaks <- nrow(ydata)
        Treal <- breaks
    }
    vnames <- dimnames(ylist[[1]])[2]
    ## Tsigbrk as dates to Tsigbrk as index into ydata
    blocktsp <- lapply(ylist, tsp)
    frq <- tsp(ylist[[1]])[3]
    if (is.matrix(Tsigbrk) && ncol(Tsigbrk) > 1){
        Tsigbrk <- Tsigbrk[ , 1] + (Tsigbrk[, 2] - 1) / frq
    }
    Tsigbrk0 <- Tsigbrk                 #save original dates
    librk <- function(ylistitem) {
        if (!isTRUE(attr(ylistitem, "dummy"))) {
            yli <- unlist(ylistitem)
            len <- dim(yli)[1]
            tsb <- invTime(Tsigbrk, yli)
            tsb <- tsb[tsb > 0 & tsb <= len]
        } else {
            numeric(0)
        }
    }
    relTsb <- lapply(ylist, librk)
    if (nblock > 1) {
        for ( ib in 2:nblock) {
            relTsb[[ib]] <- relTsb[[ib]] + breaks[ib - 1]
            ## numeric(0) (0-length vectors) are unchanged when we add a
            ## number to them
        }
    }
    Tsigbrk <- unlist(relTsb)           #Tsigbrk is now indexes into ydata
    T <- dim(ydata)[1]
    if (const) {
        xdata <- cbind(xdata, matrix(1,T,1))
    }
    if (!is.null(xdata) ) {
        stopifnot( dim(xdata)[1] == T)
        nx <- dim(xdata)[2]
    } else {
        nx <- 0
    }
    if (is.null(ic)) {
        ybar <- apply(ydata[1:lags, , drop=FALSE], 2, mean)
        if (nx > 0) {
            xbar <- apply(xdata[1:lags, , drop=FALSE], 2, mean)
        } else {
            xbar <- NULL
        }
    } else {
        ybar <- ic[1:nv]
        if (nx > 0) {
            xbar <- ic[nv + 1:nx]
        } else {
            xbar  <-  NULL}
    }
    ## What about no-prior, or training sample only, cases?
    ## Should then skip vp call, not add column to lmd, not add a "dummy regime"
    ## in Tsigbrk.
    vp <- varprior(nv,nx,lags, tight=tight, decay=decay, sig=sig, xsig=xsig,
                   w=w, lambda=lambda, mu=mu, ybar=ybar,
                   xbar=xbar, OwnLagMeans=OwnLagMeans)
    browser()
    if (T > max(breaks)) breaks <- c(breaks, T)
    if (isTRUE(length(vp$pbreaks) > 0)) breaks <- c(breaks, max(breaks) + vp$pbreaks)
    ## varprior returns NULL ydum and xdum if there are no prior dummies at all.
    ## lmd does *not* include the column of ones at the end to weight the dummies
    ## this is added in svar() whenever max(Tsigbrk) < nrow(svar ydata arg)
    var = svar(ydata=rbind(ydata, vp$ydum), lags=lags, xdata=rbind(xdata,vp$xdum),
               breaks=matrix(breaks, ncol=1), const=FALSE,
               A0=A0,lmd=lmd, Tsigbrk=c(Tsigbrk, Treal))
    ##  const is FALSE in this call because ones alread put into xdata
    if (is.null(var)) {
        print("Call to svar() failed")
        return(list(w = -Inf))
    }    
    Tu <- dim(var$u)[1]
    if ( any(var$snglty > 0) ) error( var$snglty, " redundant columns in rhs matrix")
    lmdllh <- -.5 * sum(log(var$lmdseries))
    llh <- -.5 * sum(var$u^2) + Tu * (-nv * log(2 * pi)/2 + determinant(A0)$modulus) +
        lmdllh
    ## nb: determinant() returns log of abs value of determinant
    nX <- lags * nv + 1
    intp <-  llh + .5 * sum(var$logdetxxi) + nv * nX * log(2 * pi)/2
    if (!nonorm) {
        if (isTRUE(attr(ylist[[1]], "train"))) {
            ytrain <- ylist[[1]]
            xtrain <- xlist[[1]]
            Ttrain <- dim(ytrain)[1]
            tbreaks <- breaks[breaks < Ttrain]
        } else {
            Ttrain <- 0
            ytrain <- matrix(0, 0, nv)
            xtrain <- matrix(0, 0, nx)
            tbreaks <- integer(0)
        }
        if (any(isdum)) {
            ydumManual <- ydata[(Treal + 1):T, , drop=FALSE]
            xdumManual <- xdata[(treal + 1):T, , drop=FALSE]
            mpbreaks <- breaks[breaks > Ttrain & breaks <= T] - Treal + Ttrain
        } else {
            ydumManual <- matrix(0, 0, nv)
            xdumManual <- matrix(0, 0, nx)
            mpbreaks <- integer(0)
        }
        ypriorstack <- rbind(ytrain, ydumManual, vp$ydum)
        xpriorstack <- rbind(xtrain, xdumManual, vp$xdum)
        varp <- svar(ydata=ypriorstack,
                     lags=lags,
                     xdata=xpriorstack,
                     breaks=c(tbreaks, mpbreaks, Ttrain + T - Treal + vp$pbreaks), 
                     const=FALSE,
                     A0=A0,
                     lmd=matrix(1, nv, 1),
                     Tsigbrk=dim(ypriorstack)[1]
                     )
        ## const is FALSE here because xdata already has a column of ones.
        if (any(varp$snglty > 0)) {
            warning("Prior improper, short ", varp$snglty, " df.  Results likely nonsense.")
        } else {
            Tup <- dim(varp$u)[1]
            lmdllhp <- -.5 * sum(log(varp$lmdseries))
            llhp <- -.5 * sum(varp$u^2) - Tup * (nv * log(2 * pi)/2
                - determinant(A0)$modulus) + lmdllhp
            normalizer <- .5 * sum(varp$logdetxxi) + nv * nX * log(2 * pi)/2
            pintp <- llhp + normalizer
            mdd <- intp - pintp
            llh <- llh - normalizer
            ## llh is height of posterior density over A0, lmd, A+ at peak.  w is height of
            ## marginal posterior for A0, lmd, with A+ integrated out.
        }
    } else {
        varp <- NULL
    }
    if (verbose) {
        if (nblock == 1) {
            frq <- frequency(ydata)
            uts <- ts(var$uraw[1:(Treal-lags), ],
                      start=tsp(ydata)[1] + lags / frq,
                      end=tsp(ydata)[2],
                      freq=frq)
            dimnames(uts)[2] <- dimnames(ydata)[2]
        } else {        
            uts <- list(NULL)
            blockend <- 0
            for (ils in 1:nblockReal) {
                blockstart <- blockend + 1
                blockend <- dim(ylist[[ils]])[1] + blockend - lags
                blocktsp <- tsp(ylist[[ils]])
                blocktsp[1] <- blocktsp[1] + lags / blocktsp[3]
                browser()
                uts[[ils]] <- ts(var$uraw[blockstart:blockend, ],
                                 start=blocktsp[1],
                                 end=blocktsp[2],
                                 freq=blocktsp[3]
                                 )
                dimnames(uts[[ils]])[[2]] <- vnames
            }
        }
        return(
            list(
                mdd=mdd,
                var=var,
                varp=varp,
                uts=uts,
                A0=A0,
                Tsigbrk=Tsigbrk0,
                lmd=lmd,
                prior=list(
                    tight=tight,
                    decay=decay,
                    sig=sig,
                    w=w,
                    lambda=lambda,
                    mu=mu,
                    OwnLagMeans=OwnLagMeans),
                flat=flat,
                ic=ic,
                call=match.call()
            )
        )
    } else {
        return(mdd)
    }
}
