#' Minnesota prior
#'
#' Generates dummy observations for a Minnesota prior on a VAR.
#'
#' Output of this function is used in `rfmdd()` and `svmdd()`, and can
#' be used with `rfvar()`.  
#'
#' @details
#' The model is
#' \deqn{y~t~ = B~y~(L) y~t~ + B~x~ x~t~ + \epsilon~t~},
#' where \eqn{~y~t} is an `nv` by 1 vector, \eqn{B~x~(L)} is an
#' `nv` by `nv` matrix polynomial in strictly positive powers of the
#' lag operator \eqn{L}, \eqn{B~x~} is a matrix of coefficients on
#' exogenous variables `x`.  
#' \eqn{\epsilon~t~ \sim N(0, \Sigma)(\epsilon~t~ \sim N(0, \Sigma)} conditional on
#' all \eqn{y~s~, s < t}.
#' 
#' The Minnesota prior is a normal distribution on the model's coefficients,
#' generated by "dummy observations".  The mean of the distribution is
#' determined by `OwnLagMeans`.  All coefficients have zero prior mean except
#' some "own lag" coefficients and possibly the constant term.  `OwnLagMeans`
#' can be a single number (usually 1), in which case that number is the prior
#' mean of the first lag on variable i in equation i for every i.  It can also
#' be a vector of length m, in which case it is the prior mean of the
#' coefficients on lags 1 through m, of variable i in equation i, for every
#' i.  Finally it can be an `n by m` matrix, in which the i'th row is the
#' prior mean of coefficient on lags 1 through m in equation i.
#'
#' The prior is discussed in more detail in
#' ["A Minnesota-Style Prior for VAR's"](MNpriorNotes.pdf).
#'
#' The most common case, where there is a constant term and no other `x`
#' variable, is `nx=0`, `xbar=1`, `xsig` `NULL` or 0.
#' @param nv number of endogenous variables
#' @param nx number of exogenous variables
#' @param lags number of lags
#' @param tight Weight on the individual coefficient Minnesota prior
#'              dummies.  Prior std dev on first lag is \code{1/tight}
#' @param decay Prior std dev of coefficients declines at rate `1/lag^decay`.
#' @param sig  Modal prior std deviations of resituals.  This vector
#'             is used to scale other parts of the prior, even when there
#'             are no dummy observations aimed at residual variances (`w==0`).
#' @param w Weight on dummy observations pulling residual std deviations
#'          toward `sig`.
#' @param lambda Weight on "co-persistence" dummy observations. `lambda < 0`
#'               leaves the `x` coefficients out of the dummy observation.
#' @param mu Weight on individual variable persistence dummy observations.
#'           `mu < 0` leaves the `x` coefficients out of the dummy observations.
#' @param xsig Rough scale of variation in \code{x} variables.  
#' @param ybar scale of persistence dummy observations
#' @param xbar scale of persistence dummy observation \code{x} values
#' @param OwnLagMeans prior expectation of own lag coefficients.  See details.
#'
#' @return \item{ydum}{dummy observations on y}
#'         \item{xdum}{dummy observations on x}
#'         \item{pbreaks}{locations of breaks in the dummy observations}
#' @md
#' @export
#' @import abind
varprior <-
    function(nv=1,nx=1,lags=1,tight=5, decay=.5, sig=rep(.01, nv), w=1,
             lambda=5, mu=1, xsig=NULL,
             ybar=NULL, xbar=1, OwnLagMeans=c(1.25, -.25))
{
    if (!is.null(tight))
    { ## single-coefficient prior dummy obs.
        ## each vbl and each lag has a dummy observation, and each dummy obs has values for current and lagged
        ## y's  and current x's. we separate the y's and the x's into two arrays.  The last two indexes, lag
        ## and rhsy, index the dummy observations.  
        xdum <- if(nx > 0) {
                    array(0, dim=c(lags + 1, nx, lags, nv), dimnames=list(obsno=1:(lags + 1), xvbl=1:nx, lag=1:lags, rhsy=1:nv))
                } else {
                    NULL
                }
        ydum <- array(0,dim=c(lags+1,nv,lags,nv),dimnames=list(obsno=1:(lags+1), lhsy=1:nv, lag=1:lags, rhsy=1:nv))
        if (nx > 0) {
            xdum <- array(0, dim=c(lags+1, nx, lags, nv), dimnames=list(obsno=1:(lags+1), rhsx=1:nx, lag=1:lags, rhsy=1:nv))
        } else {
            NULL
        }
        for (il in 1:lags)
        {
            ##-----debug---------
            ## browser()
            ##------------------
            ydum[il+1,,il,] <- il^decay*diag(sig,nv,nv)
        }
        ## If we have non-trivial x's, need dobs's for them, also.
        if(!is.null(xsig) && nx > 0) {
            ydumx <-  array(0, dim=c(lags + 1, nv, nx), dimnames=list(obsno=1:(lags + 1), rhsy=1:nv, dx=1:nx))
            xdumx <-  array(0, dim=c(lags + 1, nx, nx), dimnames=list(obsno=1:(lags + 1), xvbl=nx, dx=1:nx))
            xdumx[1, , ] <- diag(xsig, nx, nx)
            ## note that xvalues for obsno 2:(lags+1) don't matter.  This is one dummy obseervation,
            ## so only the "current" x is used.
        }
        if (is.matrix(OwnLagMeans)) {
            nown <- dim(OwnLagMeans)[2]
            if (nown < lags) {
                OwnLagMeans <- cbind(OwnLagMeans, matrix(0, nv, lags - nown))
            }
        } else if ( is.vector(OwnLagMeans)) {
            nown <- length(OwnLagMeans)
            OwnLagMeans <- matrix(c(rep(OwnLagMeans, each=nv), rep(0, (lags - nown) * nv)),
                                  nv, lags)
        } else {
            OwnLagMeans <-
                matrix(c(rep(OwnLagMeans, nv), rep(0, nv * (lags - 1))), nv, lags)
        }
        ## ydum[1,,1,] <- diag(vprior$sig * nstat, nv, nv) # so own lag has mean zero if nstat FALSE
        for (jv in 1:nv) {
            ydum[1, jv, , jv] <- sig[jv] * OwnLagMeans[jv, ] #
        }
        ydum <- tight * ydum
        dim(ydum) <- c(lags+1,nv,lags*nv)
        ydum <- ydum[seq(lags+1,1,by=-1),,]
        if (nx > 0) {
            xdum <- tight*xdum
            dim(xdum) <- c(lags+1, nx, lags*nv)
            xdum <- xdum[seq(lags+1,1,by=-1),,]
        } else {
            xdum <- NULL
        }
    } else {
        ydum <- NULL;
        xdum <- NULL;
    }
    if (!is.null(lambda) ) {
        ## lambda obs.  just one
        ydumur <- matrix(ybar, nrow=lags+1, ncol=nv, byrow=TRUE) * abs(lambda)
        ydumur <- array(ydumur, c(dim(ydumur), 1))
        if (nx > 0) {
            if (lambda > 0) {
                xdumur <- matrix(xbar, lags + 1, nx, byrow=TRUE) * lambda # (all but first row redundant)
            } else {
                xdumur <- matrix(0, lags + 1, nx)
            }
        }
    } else {
        ydumur <- NULL
        xdumur <- NULL
    }
    if (!is.null(mu)) {
        ## 
        ydumuri <-array(0, c(lags+1, nv, nv))
        xdumuri <- array(0, c(lags + 1, nx, nv))
        if (nx > 0) {
            if ( mu > 0) {
                xdumurim <- matrix(xbar, lags+1, nx, byrow=TRUE)
            } else {
                xdumurim <- matrix(0, lags+1, nx)
            }
        }
        for (iv in 1:nv) {
            ydumuri[ , iv, iv] <- ybar[iv]
            if (nx > 0) xdumuri[ , , iv] <- xdumurim
        }
        ydumur <- abind(ydumur, mu * ydumuri, along=3)
        if (nx > 0) xdumur <- abind(xdumur, mu * xdumuri, along=3)
    }
    if (!is.null(w))
    {
        ydum2 <- array(0,dim=c(lags+1,nv,nv))
        if (nx > 0) {
            xdum2 <- array(0,dim=c(lags+1,nx,nv))
        } else {
            xdum2 <- NULL
        }
        ## ydum2[lags+1,,] <- diag(sig,nv,nv) * w
        ## line above was a bug. w > 0 shrank coefficient on maximal lag.
        ## fixed 8/22/2021
        ydum2[1,,] <- diag(sig,nv,nv) * w 
    } else {
        ydum2 <- NULL
        xdum2 <- NULL
    }
    ## stack everything up.
    if (!is.null(ydum)) {
        dim(ydum) <- c(lags + 1, nv, lags * nv) # merge all the individual mn dobs
        ydum <- abind(ydum, ydumur, ydum2, along=3)
        breaks <- (lags+1) * (1:(dim(ydum)[3] -1)) # end of sample is not a "break".
        ydum <- aperm(ydum, c(1, 3, 2))
        ydum <- matrix(ydum, ncol=dim(ydum)[3])
        dimnames(ydum) <- list(NULL, names(sig))
    } else {
        breaks <- NULL
    }
    if (! is.null(xdum)) {
        dim(xdum) <- c(lags + 1, nx, lags * nv)
        xdum <- abind(xdum, xdumur, xdum2, along=3)
        xdum <- aperm(xdum, c(1,3,2))
        xdum <- matrix(xdum, ncol=dim(xdum)[3])
        if (!is.null(xsig)) {
            dimnames(xdum) <- list(NULL, names(xsig))
        }
    }
    return(list(ydum=ydum,xdum=xdum,pbreaks=breaks))
}
